import { useMemo } from 'react'

import { useExtension } from './hooks/useExtension'
import applyModifiers from './applyModifiers'
import { SYMBOL_CUSTOM_CLASSES } from './useHandlesOverrides'
import type {
  CssHandlesInput,
  CssHandles,
  CssHandlesOptions,
  ValueOf,
} from './typings'

const VALID_CSS_HANDLE_PATTERN = /^[^\d][\w-]+$/
const APP_NAME_PATTERN = /([^.]+)\.([^@]+)@(\d+)/

/** Verifies if the handle contains only letters, numbers and -, and does not begin with a number  */
const validateCssHandle = (handle: string) =>
  VALID_CSS_HANDLE_PATTERN.test(handle)

const parseComponentName = (componentName: string) => {
  const [, vendor, name, major] = componentName.match(APP_NAME_PATTERN) || []

  return { vendor, name, major }
}

const normalizeComponentName = (componentName: string) => {
  const { vendor, name, major } = parseComponentName(componentName)

  if (vendor && name && major) {
    return `${vendor}-${name}-${major}-x`
  }

  return null
}

const generateCssHandles = <T extends CssHandlesInput>(
  namespace: string,
  handles: T,
  modifiers?: string | string[]
) => {
  return handles.reduce((acc, handle: ValueOf<T>) => {
    const isValid = !!namespace && validateCssHandle(handle)
    const transformedHandle = `${namespace}-${handle}`

    acc[handle] = isValid
      ? modifiers
        ? applyModifiers(transformedHandle, modifiers)
        : transformedHandle
      : ''

    if (!isValid) {
      console.error(
        `Invalid CSS handle "${handle}". It should only contain letters or numbers, and should start with a letter.`
      )
    }

    return acc
  }, {} as CssHandles<T>)
}

/**
 * Useful for creating CSS handles without creating a CSS file with empty
 * declarations.
 * Receives an array of strings (e.g. ['foo', 'bar']) and returns an
 * object with generated css class names, e.g.
 * { foo: 'vendor-appname-1-x-foo', bar: 'vendor-appname-1-x-bar' }.
 */
const useCssHandles = <T extends CssHandlesInput>(
  handles: T,
  options: CssHandlesOptions = {}
): CssHandles<T> => {
  const extension = useExtension()

  const { props = {}, component = '' } = extension ?? {}
  const blockClass = props.cssHandle || props.blockClass

  const values = useMemo<CssHandles<T>>(() => {
    const { migrationFrom, classes } = options
    const normalizedComponent = normalizeComponentName(component)

    const namespaces = normalizedComponent ? [normalizedComponent] : []

    if (migrationFrom) {
      const migrations = Array.isArray(migrationFrom)
        ? migrationFrom
        : [migrationFrom]

      const normalizedMigrations = migrations
        .map(normalizeComponentName)
        .filter(
          (current) => !!current && current !== normalizedComponent
        ) as string[]

      namespaces.push(...normalizedMigrations)
    }

    if (classes) {
      if (
        process.env.NODE_ENV === 'development' &&
        classes.__classes !== SYMBOL_CUSTOM_CLASSES
      ) {
        console.error(
          '[css-handles] A custom classes object was passed that wasn\'t generated by the "useCustomClasses" hook.'
        )
        // todo: what to do in case of error?
      }
      // todo: actual custom classes code
    }

    return namespaces
      .map((componentName) =>
        generateCssHandles(componentName, handles, blockClass)
      )
      .reduce<CssHandles<T>>(
        (acc: null | CssHandles<T>, cur: CssHandles<T>) => {
          if (!acc) {
            return cur
          }

          Object.keys(cur).forEach((key: ValueOf<T>) => {
            acc[key] = `${acc[key]} ${cur[key]}`
          })

          return acc
        },
        undefined as any
      )
  }, [blockClass, component, handles, options])

  return values
}

export default useCssHandles
